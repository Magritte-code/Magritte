<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="lineProducingSpecies_8tpp" kind="file" language="C++">
    <compoundname>lineProducingSpecies.tpp</compoundname>
    <includes local="no">math.h</includes>
    <includes local="no">Eigen/Core</includes>
    <includes local="no">Eigen/Dense</includes>
    <includes refid="constants_8hpp" local="yes">tools/constants.hpp</includes>
    <includes refid="types_8hpp" local="yes">tools/types.hpp</includes>
    <includes local="yes">paracabs.hpp</includes>
    <includedby refid="lineProducingSpecies_8hpp" local="yes">/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lineProducingSpecies/lineProducingSpecies.hpp</includedby>
    <incdepgraph>
      <node id="720">
        <label>list</label>
      </node>
      <node id="711">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lineProducingSpecies/lineProducingSpecies.tpp</label>
        <link refid="lineProducingSpecies_8tpp"/>
        <childnode refid="712" relation="include">
        </childnode>
        <childnode refid="713" relation="include">
        </childnode>
        <childnode refid="714" relation="include">
        </childnode>
        <childnode refid="715" relation="include">
        </childnode>
        <childnode refid="718" relation="include">
        </childnode>
        <childnode refid="722" relation="include">
        </childnode>
      </node>
      <node id="716">
        <label>cmath</label>
      </node>
      <node id="713">
        <label>Eigen/Core</label>
      </node>
      <node id="721">
        <label>string</label>
      </node>
      <node id="714">
        <label>Eigen/Dense</label>
      </node>
      <node id="715">
        <label>tools/constants.hpp</label>
        <link refid="constants_8hpp"/>
        <childnode refid="716" relation="include">
        </childnode>
        <childnode refid="717" relation="include">
        </childnode>
      </node>
      <node id="719">
        <label>vector</label>
      </node>
      <node id="722">
        <label>paracabs.hpp</label>
      </node>
      <node id="717">
        <label>../configure.hpp</label>
        <link refid="configure_8hpp"/>
      </node>
      <node id="718">
        <label>tools/types.hpp</label>
        <link refid="types_8hpp"/>
        <childnode refid="719" relation="include">
        </childnode>
        <childnode refid="720" relation="include">
        </childnode>
        <childnode refid="721" relation="include">
        </childnode>
        <childnode refid="713" relation="include">
        </childnode>
        <childnode refid="722" relation="include">
        </childnode>
      </node>
      <node id="712">
        <label>math.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="728">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/model.hpp</label>
        <link refid="model_8hpp"/>
        <childnode refid="729" relation="include">
        </childnode>
        <childnode refid="730" relation="include">
        </childnode>
        <childnode refid="731" relation="include">
        </childnode>
      </node>
      <node id="723">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lineProducingSpecies/lineProducingSpecies.tpp</label>
        <link refid="lineProducingSpecies_8tpp"/>
        <childnode refid="724" relation="include">
        </childnode>
      </node>
      <node id="724">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lineProducingSpecies/lineProducingSpecies.hpp</label>
        <link refid="lineProducingSpecies_8hpp"/>
        <childnode refid="725" relation="include">
        </childnode>
        <childnode refid="726" relation="include">
        </childnode>
      </node>
      <node id="729">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/bindings/pybindings.cpp</label>
        <link refid="pybindings_8cpp"/>
      </node>
      <node id="730">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/model.cpp</label>
        <link refid="model_8cpp"/>
      </node>
      <node id="732">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/solver/solver.cpp</label>
        <link refid="solver_8cpp"/>
      </node>
      <node id="726">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lines.hpp</label>
        <link refid="lines_8hpp"/>
        <childnode refid="727" relation="include">
        </childnode>
        <childnode refid="728" relation="include">
        </childnode>
      </node>
      <node id="731">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/solver/solver.hpp</label>
        <link refid="solver_8hpp"/>
        <childnode refid="729" relation="include">
        </childnode>
        <childnode refid="730" relation="include">
        </childnode>
        <childnode refid="732" relation="include">
        </childnode>
      </node>
      <node id="727">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lines.cpp</label>
        <link refid="lines_8cpp"/>
      </node>
      <node id="725">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lineProducingSpecies/lineProducingSpecies.cpp</label>
        <link refid="lineProducingSpecies_8cpp"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#include<sp/>&lt;math.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;Eigen/Core&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;Eigen/Dense&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;tools/constants.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;tools/types.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;paracabs.hpp&quot;</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Indexer<sp/>for<sp/>level<sp/>populations</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>p<sp/>:<sp/>index<sp/>of<sp/>the<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>i<sp/>:<sp/>index<sp/>of<sp/>the<sp/>level</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>corresponding<sp/>index<sp/>for<sp/>p<sp/>and<sp/>i</highlight></codeline>
<codeline><highlight class="normal">//////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>Size<sp/>LineProducingSpecies<sp/>::<sp/>index<sp/>(const<sp/>Size<sp/>p,<sp/>const<sp/>Size<sp/>i)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>i<sp/>+<sp/>p*linedata.nlev;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>line<sp/>emissivity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>p<sp/>:<sp/>index<sp/>of<sp/>the<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>k<sp/>:<sp/>index<sp/>of<sp/>the<sp/>transition</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>line<sp/>emissivity<sp/>for<sp/>cell<sp/>p<sp/>and<sp/>transition<sp/>k</highlight></codeline>
<codeline><highlight class="normal">//////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>Real<sp/>LineProducingSpecies<sp/>::<sp/>get_emissivity<sp/>(const<sp/>Size<sp/>p,<sp/>const<sp/>Size<sp/>k)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Size<sp/>i<sp/>=<sp/>index<sp/>(p,<sp/>linedata.irad[k]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>HH_OVER_FOUR_PI<sp/>*<sp/>linedata.A[k]<sp/>*<sp/>population(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>line<sp/>opacity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>p<sp/>:<sp/>index<sp/>of<sp/>the<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>k<sp/>:<sp/>index<sp/>of<sp/>the<sp/>transition</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>line<sp/>opacity<sp/>for<sp/>cell<sp/>p<sp/>and<sp/>transition<sp/>k</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>Real<sp/>LineProducingSpecies<sp/>::<sp/>get_opacity<sp/>(const<sp/>Size<sp/>p,<sp/>const<sp/>Size<sp/>k)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Size<sp/>i<sp/>=<sp/>index<sp/>(p,<sp/>linedata.irad[k]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>Size<sp/>j<sp/>=<sp/>index<sp/>(p,<sp/>linedata.jrad[k]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>HH_OVER_FOUR_PI<sp/>*<sp/>(<sp/><sp/>population(j)<sp/>*<sp/>linedata.Ba[k]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>population(i)<sp/>*<sp/>linedata.Bs[k]<sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>set_LTE_level_populations</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>abundance_lspec:<sp/>abundance<sp/>of<sp/>line<sp/>species</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>temperature:<sp/>local<sp/>gas<sp/>temperature</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>p:<sp/>number<sp/>of<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>l:<sp/>number<sp/>of<sp/>line<sp/>producing<sp/>species</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>void<sp/>LineProducingSpecies<sp/>::<sp/>update_using_LTE<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Double2<sp/><sp/><sp/><sp/><sp/><sp/>&amp;abundance,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Vector&lt;Real&gt;<sp/>&amp;temperature<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>threaded_for<sp/>(p,<sp/>parameters.npoints(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population_tot[p]<sp/>=<sp/>abundance[p][linedata.num];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Real<sp/>partition_function<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>linedata.nlev;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>ind<sp/>=<sp/>index<sp/>(p,<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population(ind)<sp/>=<sp/>linedata.weight[i]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>exp<sp/>(-linedata.energy[i]<sp/>/<sp/>(KB*temperature[p]));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>partition_function<sp/>+=<sp/>population<sp/>(ind);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>linedata.nlev;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>ind<sp/>=<sp/>index<sp/>(p,<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population(ind)<sp/>*=<sp/>population_tot[p]<sp/>/<sp/>partition_function;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>})</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>populations.push_back<sp/>(population);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">inline<sp/>void<sp/>LineProducingSpecies<sp/>::<sp/>check_for_convergence<sp/>(const<sp/>Real<sp/>pop_prec)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>weight<sp/>=<sp/>1.0<sp/>/<sp/>(parameters.npoints()<sp/>*<sp/>linedata.nlev);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Real<sp/>fnc<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Real<sp/>rcm<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>relative_change_max<sp/>=<sp/>0.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/>for<sp/>(long<sp/>p<sp/>=<sp/>0;<sp/>p<sp/>&lt;<sp/>ncells;<sp/>p++)</highlight></codeline>
<codeline><highlight class="normal">#<sp/><sp/><sp/>pragma<sp/>omp<sp/>parallel<sp/>for<sp/>reduction<sp/>(+:<sp/>fnc,<sp/>rcm)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>p<sp/>=<sp/>0;<sp/>p<sp/>&lt;<sp/>parameters.npoints();<sp/>p++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>min_pop<sp/>=<sp/>1.0E-10<sp/>*<sp/>population_tot[p];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>linedata.nlev;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>ind<sp/>=<sp/>index<sp/>(p,<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(population(ind)<sp/>&gt;<sp/>min_pop)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Real<sp/>relative_change<sp/>=<sp/>2.0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>relative_change<sp/>*=<sp/>fabs<sp/>(population<sp/>(ind)<sp/>-<sp/>population_prev1<sp/>(ind));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>relative_change<sp/>/=<sp/><sp/><sp/><sp/><sp/><sp/>(population<sp/>(ind)<sp/>+<sp/>population_prev1<sp/>(ind));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(relative_change<sp/>&gt;<sp/>pop_prec)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fnc<sp/>+=<sp/>weight;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rcm<sp/>+=<sp/>(weight<sp/>*<sp/>relative_change);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>NOT<sp/>THREAD<sp/>SAFE<sp/>!!!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//if<sp/>(relative_change<sp/>&gt;<sp/>relative_change_max)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/>relative_change_max<sp/>=<sp/>relative_change;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fraction_not_converged<sp/>=<sp/>fnc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>relative_change_mean<sp/><sp/><sp/>=<sp/>rcm;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>update_using_Ng_acceleration:<sp/>perform<sp/>a<sp/>Ng<sp/>accelerated<sp/>iteration<sp/>step</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>for<sp/>level<sp/>populations.<sp/>All<sp/>variable<sp/>names<sp/>are<sp/>based<sp/>on<sp/>lecture<sp/>notes</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>by<sp/>C.P.<sp/>Dullemond<sp/>which<sp/>are<sp/>based<sp/>on<sp/>Olson,<sp/>Auer<sp/>and<sp/>Buchler<sp/>(1985).</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">void<sp/>LineProducingSpecies<sp/>::<sp/>update_using_Ng_acceleration<sp/>()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>Wt<sp/>(parameters.npoints()*linedata.nlev);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>Q1<sp/>=<sp/>population<sp/>-<sp/>2.0*population_prev1<sp/>+<sp/>population_prev2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>Q2<sp/>=<sp/>population<sp/>-<sp/><sp/><sp/><sp/><sp/>population_prev1<sp/>-<sp/>population_prev2<sp/>+<sp/>population_prev3;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>Q3<sp/>=<sp/>population<sp/>-<sp/><sp/><sp/><sp/><sp/>population_prev1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//OMP_PARALLEL_FOR<sp/>(ind,<sp/>ncells*linedata.nlev)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>if<sp/>(population<sp/>(ind)<sp/>&gt;<sp/>0.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Wt<sp/>(ind)<sp/>=<sp/>Jlin[p][k];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Wt<sp/>(ind)<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//const<sp/>double<sp/>A1<sp/>=<sp/>Q1.dot<sp/>(Wt.asDiagonal()*Q1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//const<sp/>double<sp/>A2<sp/>=<sp/>Q1.dot<sp/>(Wt.asDiagonal()*Q2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//const<sp/>double<sp/>B2<sp/>=<sp/>Q2.dot<sp/>(Wt.asDiagonal()*Q2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//const<sp/>double<sp/>C1<sp/>=<sp/>Q1.dot<sp/>(Wt.asDiagonal()*Q3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//const<sp/>double<sp/>C2<sp/>=<sp/>Q2.dot<sp/>(Wt.asDiagonal()*Q3);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>A1<sp/>=<sp/>Q1.dot(Q1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>A2<sp/>=<sp/>Q1.dot(Q2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>B2<sp/>=<sp/>Q2.dot(Q2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>C1<sp/>=<sp/>Q1.dot(Q3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>C2<sp/>=<sp/>Q2.dot(Q3);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>B1<sp/>=<sp/>A2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>denominator<sp/>=<sp/>A1*B2<sp/>-<sp/>A2*B1;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(denominator<sp/>!=<sp/>0.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>VectorXr<sp/>pop_tmp<sp/>=<sp/>population;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>a<sp/>=<sp/>(C1*B2<sp/>-<sp/>C2*B1)<sp/>/<sp/>denominator;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>b<sp/>=<sp/>(C2*A1<sp/>-<sp/>C1*A2)<sp/>/<sp/>denominator;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population<sp/>=<sp/>(1.0<sp/>-<sp/>a<sp/>-<sp/>b)*population</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>a*population_prev1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>b*population_prev2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population_prev3<sp/>=<sp/>population_prev2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population_prev2<sp/>=<sp/>population_prev1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population_prev1<sp/>=<sp/>pop_tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>update_using_acceleration:<sp/>perform<sp/>a<sp/>Ng<sp/>accelerated<sp/>iteration<sp/>step</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>for<sp/>level<sp/>populations.<sp/>All<sp/>variable<sp/>names<sp/>are<sp/>based<sp/>on<sp/>lecture<sp/>notes</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>by<sp/>C.P.<sp/>Dullemond<sp/>which<sp/>are<sp/>based<sp/>on<sp/>Olson,<sp/>Auer<sp/>and<sp/>Buchler<sp/>(1985).</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">void<sp/>LineProducingSpecies<sp/>::<sp/>update_using_acceleration<sp/>(const<sp/>Size<sp/>order)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MatrixXr<sp/>RTR<sp/>(order,<sp/>order);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>order;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>order;<sp/>j++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RTR(i,j)<sp/>=<sp/>residuals[i].dot(residuals[j]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>ones<sp/><sp/>=<sp/>VectorXr::Constant(order,<sp/>1.0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>coef<sp/><sp/>=<sp/>RTR.colPivHouseholderQr().solve(ones);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>coef<sp/>/=<sp/>coef.sum();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>residuals<sp/><sp/>.push_back(population-populations.back());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>populations.push_back(population);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>population<sp/>=<sp/>VectorXr::Zero(population.size());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>order;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>population<sp/>+=<sp/>populations[order-1-i]<sp/>*<sp/>coef[order-1-i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>update_using_statistical_equilibrium:<sp/>computes<sp/>level<sp/>populations<sp/>by<sp/>solving</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/>the<sp/>statistical<sp/>equilibrium<sp/>equation<sp/>taking<sp/>into<sp/>account<sp/>the<sp/>radiation<sp/>field</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>abundance:<sp/>chemical<sp/>abundances<sp/>of<sp/>species<sp/>in<sp/>the<sp/>model</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>temperature:<sp/>gas<sp/>temperature<sp/>in<sp/>the<sp/>model</highlight></codeline>
<codeline><highlight class="normal">/////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>void<sp/>LineProducingSpecies<sp/>::<sp/>update_using_statistical_equilibrium<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Double2<sp/><sp/><sp/><sp/><sp/><sp/>&amp;abundance,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Vector&lt;Real&gt;<sp/>&amp;temperature<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>non_zeros<sp/>=<sp/>parameters.npoints()<sp/>*<sp/>(<sp/><sp/><sp/><sp/><sp/><sp/>linedata.nlev</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>6<sp/>*<sp/>linedata.nrad</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>4<sp/>*<sp/>linedata.ncol_tot<sp/>);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>population_prev3<sp/>=<sp/>population_prev2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>population_prev2<sp/>=<sp/>population_prev1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>population_prev1<sp/>=<sp/>population;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>residuals<sp/><sp/>.push_back(population-populations.back());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>populations.push_back(population);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/>SparseMatrix&lt;double&gt;<sp/>RT<sp/>(ncells*linedata.nlev,<sp/>ncells*linedata.nlev);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>VectorXr<sp/>y<sp/>=<sp/>VectorXr::Zero<sp/>(parameters.npoints()*linedata.nlev);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vector&lt;Triplet&lt;Real,<sp/>Size&gt;&gt;<sp/>triplets;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vector&lt;Triplet&lt;Real,<sp/>Size&gt;&gt;<sp/>triplets_LT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vector&lt;Triplet&lt;Real,<sp/>Size&gt;&gt;<sp/>triplets_LS;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.reserve<sp/>(non_zeros);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>triplets_LT.reserve<sp/>(non_zeros);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>triplets_LS.reserve<sp/>(non_zeros);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>p<sp/>=<sp/>0;<sp/>p<sp/>&lt;<sp/>parameters.npoints();<sp/>p++)<sp/>//<sp/>!!!<sp/>no<sp/>OMP<sp/>because<sp/>push_back<sp/>is<sp/>not<sp/>thread<sp/>safe<sp/>!!!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Radiative<sp/>transitions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>linedata.nrad;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>v_IJ<sp/>=<sp/>linedata.A[k]<sp/>+<sp/>linedata.Bs[k]<sp/>*<sp/>Jeff[p][k];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>v_JI<sp/>=<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>linedata.Ba[k]<sp/>*<sp/>Jeff[p][k];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>t_IJ<sp/>=<sp/>linedata.Bs[k]<sp/>*<sp/>Jdif[p][k];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>t_JI<sp/>=<sp/>linedata.Ba[k]<sp/>*<sp/>Jdif[p][k];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note:<sp/>we<sp/>define<sp/>our<sp/>transition<sp/>matrix<sp/>as<sp/>the<sp/>transpose<sp/>of<sp/>R<sp/>in<sp/>the<sp/>paper.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>I<sp/>=<sp/>index<sp/>(p,<sp/>linedata.irad[k]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>J<sp/>=<sp/>index<sp/>(p,<sp/>linedata.jrad[k]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(linedata.jrad[k]<sp/>!=<sp/>linedata.nlev-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>I,<sp/>+v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>J,<sp/>-v_JI));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets_LS.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>I,<sp/>+t_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets_LS.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>J,<sp/>-t_JI));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(linedata.irad[k]<sp/>!=<sp/>linedata.nlev-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>J,<sp/>+v_JI));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>I,<sp/>-v_IJ));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets_LS.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>J,<sp/>+t_JI));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets_LS.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>I,<sp/>-t_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Approximated<sp/>Lambda<sp/>operator</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>linedata.nrad;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>m<sp/>=<sp/>0;<sp/>m<sp/>&lt;<sp/>lambda.get_size(p,k);<sp/>m++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>nr<sp/>=<sp/><sp/>lambda.get_nr(p,<sp/>k,<sp/>m);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>v_IJ<sp/>=<sp/>-lambda.get_Ls(p,<sp/>k,<sp/>m)<sp/>*<sp/>get_opacity(p,<sp/>k);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note:<sp/>we<sp/>define<sp/>our<sp/>transition<sp/>matrix<sp/>as<sp/>the<sp/>transpose<sp/>of<sp/>R<sp/>in<sp/>the<sp/>paper.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>I<sp/>=<sp/>index<sp/>(nr,<sp/>linedata.irad[k]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>J<sp/>=<sp/>index<sp/>(p,<sp/><sp/>linedata.jrad[k]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(linedata.jrad[k]<sp/>!=<sp/>linedata.nlev-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>I,<sp/>+v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets_LT.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>I,<sp/>+v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(linedata.irad[k]<sp/>!=<sp/>linedata.nlev-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets<sp/><sp/><sp/>.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>I,<sp/>-v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets_LT.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>I,<sp/>-v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Collisional<sp/>transitions</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(CollisionPartner<sp/>&amp;colpar<sp/>:<sp/>linedata.colpar)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Real<sp/>abn<sp/>=<sp/>abundance[p][colpar.num_col_partner];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Real<sp/>tmp<sp/>=<sp/>temperature[p];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>colpar.adjust_abundance_for_ortho_or_para<sp/>(tmp,<sp/>abn);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>colpar.interpolate_collision_coefficients<sp/>(tmp);</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>colpar.ncol;<sp/>k++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>v_IJ<sp/>=<sp/>colpar.Cd_intpld[k]<sp/>*<sp/>abn;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>v_JI<sp/>=<sp/>colpar.Ce_intpld[k]<sp/>*<sp/>abn;</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Note:<sp/>we<sp/>define<sp/>our<sp/>transition<sp/>matrix<sp/>as<sp/>the<sp/>transpose<sp/>of<sp/>R<sp/>in<sp/>the<sp/>paper.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>I<sp/>=<sp/>index<sp/>(p,<sp/>colpar.icol[k]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>J<sp/>=<sp/>index<sp/>(p,<sp/>colpar.jcol[k]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(colpar.jcol[k]<sp/>!=<sp/>linedata.nlev-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>I,<sp/>+v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(J,<sp/>J,<sp/>-v_JI));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(colpar.icol[k]<sp/>!=<sp/>linedata.nlev-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>J,<sp/>+v_JI));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>I,<sp/>-v_IJ));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>linedata.nlev;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>I<sp/>=<sp/>index<sp/>(p,<sp/>linedata.nlev-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>J<sp/>=<sp/>index<sp/>(p,<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>triplets.push_back<sp/>(Triplet&lt;Real,<sp/>Size&gt;<sp/>(I,<sp/>J,<sp/>1.0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//y.insert<sp/>(index<sp/>(p,<sp/>linedata.nlev-1))<sp/>=<sp/>population_tot[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>y[index<sp/>(p,<sp/>linedata.nlev-1)]<sp/>=<sp/>population_tot[p];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//y.insert<sp/>(index<sp/>(p,<sp/>linedata.nlev-1))<sp/>=<sp/>1.0;//population_tot[p];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>//<sp/>for<sp/>all<sp/>cells</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RT<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.setFromTriplets<sp/>(triplets<sp/><sp/><sp/>.begin(),<sp/>triplets<sp/><sp/><sp/>.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>LambdaStar.setFromTriplets<sp/>(triplets_LS.begin(),<sp/>triplets_LS.end());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>LambdaTest.setFromTriplets<sp/>(triplets_LT.begin(),<sp/>triplets_LT.end());</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//cout<sp/>&lt;&lt;<sp/>&quot;Compressing<sp/>RT&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//RT.makeCompressed<sp/>();</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//Eigen::BiCGSTAB<sp/>&lt;SparseMatrix&lt;double&gt;&gt;<sp/>solver;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//cout<sp/>&lt;&lt;<sp/>&quot;Try<sp/>compute&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//solver.compute<sp/>(RT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//if<sp/>(solver.info()<sp/>!=<sp/>Eigen::Success)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Decomposition<sp/>failed&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>//assert(false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//for<sp/>(int<sp/>tel=0;<sp/>tel&lt;5;<sp/>tel++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>//Eigen::Gues<sp/>x0<sp/>=<sp/>population;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>population<sp/>=<sp/>solver.solveWithGuess<sp/>(y,<sp/>population);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;#iterations:<sp/><sp/><sp/><sp/><sp/>&quot;<sp/>&lt;&lt;<sp/>solver.iterations()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;estimated<sp/>error:<sp/>&quot;<sp/>&lt;&lt;<sp/>solver.error()<sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//assert<sp/>(false);</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SparseLU<sp/>&lt;SparseMatrix&lt;Real&gt;,<sp/>COLAMDOrdering&lt;int&gt;&gt;<sp/>solver;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//Eigen::SimplicialLDLT&lt;Eigen::SparseMatrix&lt;double&gt;&gt;<sp/>solver;</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Analyzing<sp/>system<sp/>of<sp/>rate<sp/>equations...&quot;<sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>solver.analyzePattern<sp/>(RT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Factorizing<sp/>system<sp/>of<sp/>rate<sp/>equations...&quot;<sp/><sp/><sp/><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>solver.factorize<sp/>(RT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(solver.info()<sp/>!=<sp/>Eigen::Success)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Factorization<sp/>failed<sp/>with<sp/>error<sp/>message:&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>solver.lastErrorMessage()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>cout<sp/>&lt;&lt;<sp/>endl<sp/>&lt;&lt;<sp/>RT<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>std::runtime_error<sp/>(&quot;Eigen<sp/>solver<sp/>ERROR.&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//cout<sp/>&lt;&lt;<sp/>&quot;Try<sp/>compute&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//solver.compute<sp/>(RT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//if<sp/>(solver.info()<sp/>!=<sp/>Eigen::Success)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Decomposition<sp/>failed&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>//assert(false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Solving<sp/>rate<sp/>equations<sp/>for<sp/>the<sp/>level<sp/>populations...&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>population<sp/>=<sp/>solver.solve<sp/>(y);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(solver.info()<sp/>!=<sp/>Eigen::Success)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Solving<sp/>failed<sp/>with<sp/>error:&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>solver.lastErrorMessage()<sp/><sp/><sp/><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert<sp/>(false);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;Succesfully<sp/>solved<sp/>for<sp/>the<sp/>level<sp/>populations!&quot;<sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//OMP_PARALLEL_FOR<sp/>(p,<sp/>ncells)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>for<sp/>(long<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>linedata.nlev;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>const<sp/>long<sp/>I<sp/>=<sp/>index<sp/>(p,<sp/>i);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>population[I]<sp/>=<sp/>population_prev1[I];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>//if<sp/>(population[I]<sp/>&lt;<sp/>1.0E-50)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>//<sp/><sp/>population[I]<sp/>=<sp/>1.0E-50;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/frederik/Dropbox/GitHub/Magritte/src/model/lines/lineProducingSpecies/lineProducingSpecies.tpp"/>
  </compounddef>
</doxygen>
