<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="geometry_8tpp" kind="file" language="C++">
    <compoundname>geometry.tpp</compoundname>
    <includes local="no">limits</includes>
    <includes local="no">cmath</includes>
    <includedby refid="geometry_8hpp" local="yes">/home/frederik/Dropbox/GitHub/Magritte/src/model/geometry/geometry.hpp</includedby>
    <incdepgraph>
      <node id="357">
        <label>limits</label>
      </node>
      <node id="356">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/geometry/geometry.tpp</label>
        <link refid="geometry_8tpp"/>
        <childnode refid="357" relation="include">
        </childnode>
        <childnode refid="358" relation="include">
        </childnode>
      </node>
      <node id="358">
        <label>cmath</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="364">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/model.hpp</label>
        <link refid="model_8hpp"/>
        <childnode refid="365" relation="include">
        </childnode>
        <childnode refid="366" relation="include">
        </childnode>
        <childnode refid="367" relation="include">
        </childnode>
      </node>
      <node id="360">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/geometry/geometry.hpp</label>
        <link refid="geometry_8hpp"/>
        <childnode refid="361" relation="include">
        </childnode>
        <childnode refid="362" relation="include">
        </childnode>
        <childnode refid="364" relation="include">
        </childnode>
      </node>
      <node id="359">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/geometry/geometry.tpp</label>
        <link refid="geometry_8tpp"/>
        <childnode refid="360" relation="include">
        </childnode>
      </node>
      <node id="362">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/image/image.hpp</label>
        <link refid="image_8hpp"/>
        <childnode refid="363" relation="include">
        </childnode>
        <childnode refid="364" relation="include">
        </childnode>
      </node>
      <node id="365">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/bindings/pybindings.cpp</label>
        <link refid="pybindings_8cpp"/>
      </node>
      <node id="366">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/model.cpp</label>
        <link refid="model_8cpp"/>
      </node>
      <node id="363">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/image/image.cpp</label>
        <link refid="image_8cpp"/>
      </node>
      <node id="368">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/solver/solver.cpp</label>
        <link refid="solver_8cpp"/>
      </node>
      <node id="367">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/solver/solver.hpp</label>
        <link refid="solver_8hpp"/>
        <childnode refid="365" relation="include">
        </childnode>
        <childnode refid="366" relation="include">
        </childnode>
        <childnode refid="368" relation="include">
        </childnode>
      </node>
      <node id="361">
        <label>/home/frederik/Dropbox/GitHub/Magritte/src/model/geometry/geometry.cpp</label>
        <link refid="geometry_8cpp"/>
      </node>
    </invincdepgraph>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">#include<sp/>&lt;limits&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cmath&gt;</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>ray<sp/>and<sp/>its<sp/>distance<sp/>along<sp/>ray<sp/>in</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/>the<sp/>general<sp/>case<sp/>without<sp/>any<sp/>further<sp/>assumptions</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>o<sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>r<sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>put<sp/>last<sp/>on<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in/out]<sp/><sp/>Z<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[out]<sp/><sp/><sp/><sp/>dZ<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>distance<sp/>increment<sp/>to<sp/>the<sp/>next<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>the<sp/>ray<sp/>after<sp/>the<sp/>current<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">accel<sp/>inline<sp/>Size<sp/>Geometry<sp/>::<sp/>get_next_general_geometry<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>Z,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>dZ<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/><sp/>n_nbs<sp/>=<sp/>points.<sp/><sp/><sp/><sp/>n_neighbors[c];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>cum_n_nbs<sp/>=<sp/>points.cum_n_neighbors[c];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>dmin<sp/>=<sp/>std::numeric_limits&lt;Real&gt;::max();<sp/><sp/><sp/>//<sp/>Initialize<sp/>to<sp/>&quot;infinity&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Size<sp/><sp/><sp/>next<sp/>=<sp/>parameters.npoints();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>return<sp/>npoints<sp/>when<sp/>there<sp/>is<sp/>no<sp/>next</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>nnbs;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n_nbs;<sp/>i++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/><sp/>n<sp/><sp/><sp/><sp/><sp/>=<sp/>points.nbs[c*nnbs+i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/><sp/>n<sp/><sp/><sp/><sp/><sp/>=<sp/>points.neighbors[cum_n_nbs+i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Vector3D<sp/>R<sp/><sp/><sp/><sp/><sp/>=<sp/>points.position[n]<sp/>-<sp/>points.position[o];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/><sp/><sp/>Z_new<sp/>=<sp/>R.dot(rays.direction[r]);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(Z_new<sp/>&gt;<sp/>Z)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>distance_from_ray2<sp/>=<sp/>R.dot(R)<sp/>-<sp/>Z_new*Z_new;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(distance_from_ray2<sp/>&lt;<sp/>dmin)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dmin<sp/>=<sp/>distance_from_ray2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>n;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dZ<sp/><sp/><sp/>=<sp/>Z_new<sp/>-<sp/>Z;<sp/><sp/><sp/>//<sp/>such<sp/>that<sp/>dZ<sp/>&gt;<sp/>0.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Update<sp/>distance<sp/>along<sp/>ray</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Z<sp/>+=<sp/>dZ;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>next;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>ray<sp/>and<sp/>its<sp/>distance<sp/>along<sp/>ray<sp/>when</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/>assuming<sp/>spherical<sp/>symmetry<sp/>and<sp/>such<sp/>that<sp/>the<sp/>positions<sp/>are<sp/>in<sp/>ascending<sp/>order!</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>o<sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>r<sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>put<sp/>last<sp/>on<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in/out]<sp/><sp/>Z<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[out]<sp/><sp/><sp/><sp/>dZ<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>distance<sp/>increment<sp/>to<sp/>the<sp/>next<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>the<sp/>ray<sp/>after<sp/>the<sp/>current<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>Size<sp/>Geometry<sp/>::<sp/>get_next_spherical_symmetry<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/><sp/><sp/><sp/><sp/>&amp;Z,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/><sp/><sp/><sp/><sp/>&amp;dZ<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Size<sp/>next;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rsin<sp/>=<sp/>points.position[o].x()<sp/>*<sp/>rays.direction[r].y();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rcos<sp/>=<sp/>points.position[o].x()<sp/>*<sp/>rays.direction[r].x();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rsin2<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Rsin<sp/>*<sp/>Rsin;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rcos_plus_Z<sp/>=<sp/>Rcos<sp/>+<sp/>Z;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(Z<sp/>&lt;<sp/>-Rcos)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(c<sp/>&lt;=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>parameters.npoints();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(points.position[c-1].squaredNorm()<sp/>&gt;=<sp/>Rsin2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>c<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dZ<sp/><sp/><sp/>=<sp/>-sqrt(points.position[next].squaredNorm()<sp/>-<sp/>Rsin2)<sp/>-<sp/>Rcos_plus_Z;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>c;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dZ<sp/><sp/><sp/>=<sp/>-<sp/>2.0<sp/>*<sp/>Rcos_plus_Z;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(c<sp/>&gt;=<sp/>parameters.npoints()-1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>parameters.npoints();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>c<sp/>+<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dZ<sp/><sp/><sp/>=<sp/>+sqrt(points.position[next].squaredNorm()<sp/>-<sp/>Rsin2)<sp/>-<sp/>Rcos_plus_Z;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Update<sp/>distance<sp/>along<sp/>ray</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Z<sp/>+=<sp/>dZ;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>cout<sp/>&lt;&lt;<sp/>&quot;o<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>o<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/><sp/><sp/>r<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>r<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/><sp/>c<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>c<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/><sp/>next<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>next<sp/>&lt;&lt;<sp/>&quot;dZ<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>dZ<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>next;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>o<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>r<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>crt<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>for<sp/>which<sp/>we<sp/>want<sp/>the<sp/>velocity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>double<sp/>Geometry<sp/>::<sp/>get_shift_general_geometry<sp/>&lt;CoMoving&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>crt<sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>1.0<sp/>-<sp/>(points.velocity[crt]<sp/>-<sp/>points.velocity[o]).dot(rays.direction[r]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>o<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>r<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>crt<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>for<sp/>which<sp/>we<sp/>want<sp/>the<sp/>velocity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>double<sp/>Geometry<sp/>::<sp/>get_shift_general_geometry<sp/>&lt;Rest&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/>crt<sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Size<sp/>r_correct<sp/>=<sp/>r;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(r<sp/>&gt;=<sp/>parameters.hnrays())<sp/>//<sp/>assumes<sp/>ray<sp/>indices<sp/>and<sp/>antipodes<sp/>are<sp/>on<sp/>opposite<sp/>sites<sp/>of<sp/>hnrays</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r_correct<sp/>=<sp/>rays.antipod[r];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>1.0<sp/>-<sp/>points.velocity[crt].dot(rays.direction[r_correct]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">accel<sp/>inline<sp/>Size<sp/>Geometry<sp/>::<sp/>get_n_interpl<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>shift_crt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>shift_nxt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>dshift_max<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>dshift_abs<sp/>=<sp/>fabs<sp/>(shift_nxt<sp/>-<sp/>shift_crt);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(dshift_abs<sp/>&gt;<sp/>dshift_max)<sp/>{return<sp/>dshift_abs/dshift_max<sp/>+<sp/>1;}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{return<sp/>1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;Frame<sp/>frame&gt;</highlight></codeline>
<codeline><highlight class="normal">accel<sp/>inline<sp/>Size<sp/>Geometry<sp/>::<sp/>get_ray_length<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>dshift_max<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Size<sp/><sp/><sp/><sp/>l<sp/>=<sp/>0;<sp/><sp/><sp/><sp/><sp/>//<sp/>ray<sp/>length</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/><sp/>Z<sp/>=<sp/>0.0;<sp/><sp/><sp/>//<sp/>distance<sp/>from<sp/>origin<sp/>(o)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>double<sp/>dZ<sp/>=<sp/>0.0;<sp/><sp/><sp/>//<sp/>last<sp/>increment<sp/>in<sp/>Z</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Size<sp/>nxt<sp/>=<sp/>get_next<sp/>(o,<sp/>r,<sp/>o,<sp/>Z,<sp/>dZ);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(valid_point(nxt))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Size<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>crt<sp/>=<sp/>o;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>shift_crt<sp/>=<sp/>get_shift<sp/>&lt;frame&gt;<sp/>(o,<sp/>r,<sp/>crt,<sp/>Z);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>shift_nxt<sp/>=<sp/>get_shift<sp/>&lt;frame&gt;<sp/>(o,<sp/>r,<sp/>nxt,<sp/>Z);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l<sp/>+=<sp/>get_n_interpl<sp/>(shift_crt,<sp/>shift_nxt,<sp/>dshift_max);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(not_on_boundary(nxt))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>crt<sp/>=<sp/><sp/><sp/><sp/><sp/><sp/><sp/>nxt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shift_crt<sp/>=<sp/>shift_nxt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nxt<sp/>=<sp/>get_next<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(o,<sp/>r,<sp/>nxt,<sp/>Z,<sp/>dZ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shift_nxt<sp/>=<sp/>get_shift<sp/>&lt;frame&gt;<sp/>(o,<sp/>r,<sp/>nxt,<sp/>Z<sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l<sp/>+=<sp/>get_n_interpl<sp/>(shift_crt,<sp/>shift_nxt,<sp/>dshift_max);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>l;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>inline<sp/>Size1<sp/>Geometry<sp/>::<sp/>get_ray_lengths<sp/>()</highlight></codeline>
<codeline><highlight class="normal">//<sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>rr<sp/>=<sp/>0;<sp/>rr<sp/>&lt;<sp/>parameters.hnrays();<sp/>rr++)</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>ar<sp/>=<sp/>rays.antipod[rr];</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cout<sp/>&lt;&lt;<sp/>&quot;rr<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>rr<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>threaded_for<sp/>(o,<sp/>parameters.npoints(),</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Real<sp/>dshift_max<sp/>=<sp/>1.0e+99;</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lengths.vec[parameters.npoints()*rr+o]<sp/>=</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>get_ray_length<sp/>&lt;CoMoving&gt;<sp/>(o,<sp/>rr,<sp/>dshift_max)</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>get_ray_length<sp/>&lt;CoMoving&gt;<sp/>(o,<sp/>ar,<sp/>dshift_max);</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>})</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>return<sp/>lengths.vec;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>template<sp/>&lt;Frame<sp/>frame&gt;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>inline<sp/>void<sp/>Geometry<sp/>::<sp/>get_ray_lengths<sp/>(const<sp/>Real<sp/>dshift_max)</highlight></codeline>
<codeline><highlight class="normal">//<sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>for<sp/>(Size<sp/>rr<sp/>=<sp/>0;<sp/>rr<sp/>&lt;<sp/>parameters.hnrays();<sp/>rr++)</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Size<sp/>ar<sp/>=<sp/>rays.antipod[rr];</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accelerated_for<sp/>(o,<sp/>parameters.npoints(),<sp/>nblocks,<sp/>nthreads,</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lengths(rr,o)<sp/>=<sp/><sp/>get_ray_length<sp/>&lt;frame&gt;<sp/>(o,<sp/>rr,<sp/>dshift_max)</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>get_ray_length<sp/>&lt;frame&gt;<sp/>(o,<sp/>ar,<sp/>dshift_max);</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>})</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc::accelerator::synchronize();</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">//</highlight></codeline>
<codeline><highlight class="normal">//<sp/><sp/><sp/><sp/><sp/>lengths.copy_ptr_to_vec();</highlight></codeline>
<codeline><highlight class="normal">//<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Check<sp/>whether<sp/>a<sp/>point<sp/>index<sp/>is<sp/>valid</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>p<sp/>:<sp/>point<sp/>index</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@returns<sp/>true<sp/>if<sp/>p<sp/>is<sp/>a<sp/>valid<sp/>index</highlight></codeline>
<codeline><highlight class="normal">//////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>bool<sp/>Geometry<sp/>::<sp/>valid_point<sp/>(const<sp/>Size<sp/>p)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(p<sp/>&lt;<sp/>parameters.npoints());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Check<sp/>whether<sp/>a<sp/>point<sp/>is<sp/>not<sp/>on<sp/>the<sp/>boundary</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>p<sp/>:<sp/>point<sp/>index</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@returns<sp/>true<sp/>if<sp/>p<sp/>is<sp/>not<sp/>on<sp/>the<sp/>boundary</highlight></codeline>
<codeline><highlight class="normal">/////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>bool<sp/>Geometry<sp/>::<sp/>not_on_boundary<sp/>(const<sp/>Size<sp/>p)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(boundary.point2boundary[p]<sp/>==<sp/>parameters.npoints());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>ray<sp/>and<sp/>its<sp/>distance<sp/>along<sp/>ray<sp/>in</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/>the<sp/>general<sp/>case<sp/>without<sp/>any<sp/>further<sp/>assumptions</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>o<sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>r<sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>put<sp/>last<sp/>on<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in/out]<sp/><sp/>Z<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[out]<sp/><sp/><sp/><sp/>dZ<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>distance<sp/>increment<sp/>to<sp/>the<sp/>next<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>the<sp/>ray<sp/>after<sp/>the<sp/>current<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">accel<sp/>inline<sp/>Size<sp/>Geometry<sp/>::<sp/>get_next<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>crt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>Z,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>dZ<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Size<sp/>next;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(parameters.spherical_symmetry())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>get_next_spherical_symmetry<sp/>(o,<sp/>r,<sp/>crt,<sp/>Z,<sp/>dZ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>get_next_general_geometry<sp/><sp/><sp/>(o,<sp/>r,<sp/>crt,<sp/>Z,<sp/>dZ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//if<sp/>(!valid_point<sp/>(next))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>printf<sp/>(&quot;ERROR<sp/>(next<sp/>is<sp/>not<sp/>valid):<sp/>o<sp/>=<sp/>%d,<sp/>crt<sp/>=<sp/>%d,<sp/>ray<sp/>=<sp/>%d\n&quot;,<sp/>o,<sp/>crt,<sp/>r);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>next;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>ray<sp/>and<sp/>its<sp/>distance<sp/>along<sp/>ray<sp/>in</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/>the<sp/>general<sp/>case<sp/>without<sp/>any<sp/>further<sp/>assumptions</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>o<sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>r<sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>put<sp/>last<sp/>on<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in/out]<sp/><sp/>Z<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[out]<sp/><sp/><sp/><sp/>dZ<sp/>:<sp/>reference<sp/>to<sp/>the<sp/>distance<sp/>increment<sp/>to<sp/>the<sp/>next<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>number<sp/>of<sp/>the<sp/>next<sp/>cell<sp/>on<sp/>the<sp/>ray<sp/>after<sp/>the<sp/>current<sp/>cell</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">accel<sp/>inline<sp/>void<sp/>Geometry<sp/>::<sp/>get_next<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/><sp/>crt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Size&amp;<sp/><sp/><sp/>nxt,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>Z,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>dZ,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double&amp;<sp/>shift<sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nxt<sp/><sp/><sp/>=<sp/>get_next<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(o,<sp/>r,<sp/>crt,<sp/>Z,<sp/>dZ);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>shift<sp/>=<sp/>get_shift<sp/>&lt;CoMoving&gt;<sp/>(o,<sp/>r,<sp/>nxt,<sp/>Z<sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>o<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>r<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>crt<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>for<sp/>which<sp/>we<sp/>want<sp/>the<sp/>velocity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>Z<sp/><sp/><sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">template&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>double<sp/>Geometry<sp/>::<sp/>get_shift_spherical_symmetry<sp/>&lt;CoMoving&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Z<sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(points.position[o].x()<sp/>==<sp/>0.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(points.position[c].x()<sp/>==<sp/>0.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1.0<sp/>+<sp/>points.velocity[o].x()<sp/>*<sp/>rays.direction[r].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rcos_plus_Z<sp/>=<sp/>points.position[o].x()<sp/>*<sp/>rays.direction[r].x()<sp/>+<sp/>Z;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>1.0<sp/>-<sp/>(<sp/><sp/>points.velocity[c].x()<sp/>*<sp/>Rcos_plus_Z<sp/>/<sp/>points.position[c].x()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-<sp/>points.velocity[o].x()<sp/>*<sp/>rays.direction[r].x()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>o<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>r<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>crt<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>for<sp/>which<sp/>we<sp/>want<sp/>the<sp/>velocity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>Z<sp/><sp/><sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">template&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>double<sp/>Geometry<sp/>::<sp/>get_shift_spherical_symmetry<sp/>&lt;Rest&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Z<sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(points.position[c].x()<sp/>==<sp/>0.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rcos_plus_Z<sp/>=<sp/>points.position[o].x()<sp/>*<sp/>rays.direction[r].x()<sp/>+<sp/>Z;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>double<sp/>shift;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(r<sp/>&lt;<sp/>parameters.hnrays())<sp/>//<sp/>assumes<sp/>ray<sp/>indices<sp/>and<sp/>antipodes<sp/>are<sp/>on<sp/>opposite<sp/>sites<sp/>of<sp/>hnrays</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1.0<sp/>-<sp/>points.velocity[c].x()<sp/>*<sp/>Rcos_plus_Z<sp/>/<sp/>points.position[c].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>1.0<sp/>+<sp/>points.velocity[c].x()<sp/>*<sp/>Rcos_plus_Z<sp/>/<sp/>points.position[c].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>cout<sp/>&lt;&lt;<sp/>&quot;r<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>r<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/>o<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>o<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/>c<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>c<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/>&quot;<sp/>&lt;&lt;<sp/>shift<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>return<sp/>shift;</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>const<sp/>double<sp/>shift<sp/>=<sp/>1.0<sp/>-<sp/>points.velocity[c].x()<sp/>*<sp/>Rcos_plus_Z<sp/>/<sp/>points.position[c].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>return<sp/>shift;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//if<sp/>(rays.direction[r].x()<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>const<sp/>double<sp/>shift<sp/>=<sp/>1.0<sp/>-<sp/>points.velocity[c].x()<sp/>*<sp/>Rcos_plus_Z<sp/>/<sp/>points.position[c].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>return<sp/>shift;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>const<sp/>double<sp/>shift<sp/>=<sp/>1.0<sp/>+<sp/>points.velocity[c].x()<sp/>*<sp/>Rcos_plus_Z<sp/>/<sp/>points.position[c].x();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>return<sp/>shift;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/><sp/>Getter<sp/>for<sp/>the<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>o<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>cell<sp/>from<sp/>which<sp/>the<sp/>ray<sp/>originates</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>r<sp/><sp/><sp/>:<sp/>number<sp/>of<sp/>the<sp/>ray<sp/>along<sp/>which<sp/>we<sp/>are<sp/>looking</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>crt<sp/>:<sp/>number<sp/>of<sp/>the<sp/>cell<sp/>for<sp/>which<sp/>we<sp/>want<sp/>the<sp/>velocity</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@param[in]<sp/>Z<sp/><sp/><sp/>:<sp/>reference<sp/>to<sp/>the<sp/>current<sp/>distance<sp/>along<sp/>the<sp/>ray</highlight></codeline>
<codeline><highlight class="normal">///<sp/><sp/><sp/><sp/>@return<sp/>doppler<sp/>shift<sp/>along<sp/>the<sp/>ray<sp/>between<sp/>the<sp/>current<sp/>cell<sp/>and<sp/>the<sp/>origin</highlight></codeline>
<codeline><highlight class="normal">///////////////////////////////////////////////////////////////////////////////////////</highlight></codeline>
<codeline><highlight class="normal">template&lt;Frame<sp/>frame&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>double<sp/>Geometry<sp/>::<sp/>get_shift<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>o,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>Size<sp/><sp/><sp/>c,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Z<sp/>)<sp/>const</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(parameters.spherical_symmetry())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>get_shift_spherical_symmetry<sp/>&lt;frame&gt;<sp/>(o,<sp/>r,<sp/>c,<sp/>Z);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>get_shift_general_geometry<sp/>&lt;frame&gt;<sp/>(o,<sp/>r,<sp/>c);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/frederik/Dropbox/GitHub/Magritte/src/model/geometry/geometry.tpp"/>
  </compounddef>
</doxygen>
